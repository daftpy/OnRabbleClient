/*!
    \page index.html
    \title OnRabbleClient Developer Guide

    \section1 Overview

    OnRabbleClient is a lightweight, extensible chat client designed for real-time communication
    via secure WebSocket connections. It is part of the OnRabble suite and communicates with
    a Go-based backend and PostgreSQL/Keycloak for authentication and data storage.

    This guide provides a high-level understanding of the client architecture, message handling,
    and key types exposed to QML.

    \section1 Architecture Highlights

    - Written in modern C++ and QML with a focus on modularity and testability
    - Integrates with Keycloak for authentication and JWT-based identity
    - Uses Qt WebSockets for persistent, real-time messaging
    - Provides proxy models to filter and observe message data in QML
    - Designed to work with declarative UI via QML bindings

    \section1 Core Components

    These are the main C++ components that power the system and are exposed to QML:

    \list
        \li \l {ClientManager} — Manages connection lifecycle, access tokens, and proxy access
        \li \l {MessageBroker} — Parses inbound messages and emits signals for QML bindings
    \endlist

    \section1 Payload Types

    Payloads are structured data containers used for chat messages, channel metadata, and
    discovery information. They are deserialized from JSON and used across components and models.

    See \l {payloads.html} for the complete list of payload types.

    \section1 Extending the System

    To add support for a new message type or system behavior:

    \list
        \li Add parsing logic to \c MessageBroker::processMessage()
        \li Define a payload type if the structure is nontrivial
        \li Emit an appropriate signal or update a model
        \li Expose the result to QML if needed
    \endlist

    \note QML components automatically react to model updates and proxy signals when properly bound.

    \sa ClientManager, MessageBroker, {payloads.html}
*/
